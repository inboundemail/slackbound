---
description: Component patterns, structure, and conventions for dashboard components
---

# Component Design Patterns

## File Structure

### Component Organization
```
app/(dashboard)/
├── page.tsx              # Route component (minimal, delegates to feature)
├── feature.tsx           # Main feature component
└── featureHelpers/       # Co-located helper components
    ├── helper-one.tsx
    └── helper-two.tsx
```

### Example Pattern
```tsx
// page.tsx - Keep minimal
import FeaturePage from "./feature";

const Page = () => {
  return <FeaturePage />;
};

export default Page;

// feature.tsx - Main logic
"use client";
import HelperComponent from "./featureHelpers/helper-component";

const FeaturePage = () => {
  // Component logic
  return <div>...</div>;
};
```

## Client vs Server Components

### Client Components
- Mark with `"use client"` directive at the top
- Use for: forms, interactive UI, hooks, state management
- Most dashboard components should be client components

```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";

const InteractiveComponent = () => {
  const [state, setState] = useState();
  return <Button onClick={() => setState(...)}>Click</Button>;
};
```

### Server Components
- Default in Next.js App Router
- Use for: static layouts, data fetching at route level
- No hooks, no interactivity

## Component Naming

### Files
- PascalCase for components: `InvoiceForm.tsx`
- camelCase for utilities: `invoiceHelpers/`
- Suffix helper directories: `invoiceHelpers/`, `invoiceOptionHelpers/`

### Components
```tsx
// Feature components - descriptive names
const InvoiceForm = () => { ... }
const AssetUploadModal = () => { ... }

// Helper components - prefixed with feature name
const InvoiceItemsSection = () => { ... }
const InvoiceTemplateSelector = () => { ... }

// Generic components - clear purpose
const PDFViewer = () => { ... }
const EmptySection = () => { ... }
```

## Component Structure Pattern

### Standard Structure
```tsx
"use client";

// 1. React and third-party imports
import React, { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";

// 2. UI components (grouped)
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import { Form } from "@/components/ui/form/form";

// 3. Local components
import HelperComponent from "./helpers/helper-component";

// 4. Utilities and hooks
import { useTRPC } from "@/trpc/client";
import { cn } from "@/lib/utils";

// 5. Types and constants
import type { Invoice } from "@/types/common/invoice";
import { ERROR_MESSAGES } from "@/constants/issues";

// 6. TypeScript interfaces for props
interface ComponentProps {
  form: UseFormReturn<Schema>;
  isLoading?: boolean;
}

// 7. Component definition
const Component: React.FC<ComponentProps> = ({ form, isLoading = false }) => {
  // State
  const [open, setOpen] = useState(false);

  // Hooks (queries, mutations, custom hooks)
  const trpc = useTRPC();
  const query = useQuery({ ... });

  // Effects
  useEffect(() => { ... }, []);

  // Handlers
  const handleSubmit = () => { ... };

  // Render
  return <div>...</div>;
};

export default Component;
```

## Common Component Patterns

### Empty States
```tsx
<EmptySection
  title="No data found"
  description="Add some items to get started"
/>
```

### Loading States
```tsx
if (query.isLoading) {
  return (
    <div className="flex h-full items-center justify-center">
      <EmptySection
        title="Loading..."
        description="Please wait"
      />
    </div>
  );
}
```

### Error States
```tsx
if (query.isError) {
  return (
    <div className="flex h-full items-center justify-center text-red-500">
      <EmptySection
        title={ERROR_MESSAGES.DEFAULT}
        description={query.failureReason}
      />
    </div>
  );
}
```

### Conditional Server Features
```tsx
{session?.user && (
  <ServerOnlyFeature />
)}

{user?.allowedSavingData && (
  <UploadComponent type="server" />
)}
```

## Dialog/Modal Pattern

### Standard Dialog Structure
```tsx
<Dialog open={open} onOpenChange={setOpen}>
  <DialogTrigger asChild>
    <Button>Open</Button>
  </DialogTrigger>
  <DialogContent>
    <DialogHeaderContainer>
      <DialogIcon>
        <IconComponent />
      </DialogIcon>
      <DialogHeader>
        <DialogTitle>Dialog Title</DialogTitle>
        <DialogDescription>Dialog description</DialogDescription>
      </DialogHeader>
    </DialogHeaderContainer>
    <DialogContentContainer>
      {/* Main content */}
    </DialogContentContainer>
    <DialogFooter>
      <DialogClose asChild>
        <Button variant="outline">Cancel</Button>
      </DialogClose>
      <Button>Confirm</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

## Sheet Pattern

### Standard Sheet Structure
```tsx
<Sheet open={sheetOpen} onOpenChange={setSheetOpen}>
  <SheetTrigger>{children}</SheetTrigger>
  <SheetContent className="scroll-bar-hidden w-[90%] !max-w-lg overflow-y-scroll">
    <SheetHeader className="hidden flex-col gap-0">
      <SheetTitle>Title</SheetTitle>
      <SheetDescription>Description</SheetDescription>
    </SheetHeader>
    <div className="flex flex-col gap-4 p-4">
      {/* Content */}
    </div>
  </SheetContent>
</Sheet>
```

## Accordion Pattern

### Form Accordion Structure
```tsx
<Accordion type="single" collapsible defaultValue="section-id" className="w-full divide-y border-b">
  <AccordionItem value="section-id">
    <AccordionTrigger>Section Title</AccordionTrigger>
    <AccordionContent>
      {/* Form fields */}
    </AccordionContent>
  </AccordionItem>
</Accordion>
```

### Multiple Sections
```tsx
<Accordion
  type="multiple"
  defaultValue={["section-1", "section-2"]}
  className="w-full divide-y border-b"
>
  {/* Multiple AccordionItems */}
</Accordion>
```

## List/Grid Patterns

### Grid Layout for Items
```tsx
<div className="grid grid-cols-2 gap-4 md:grid-cols-3">
  {items.map((item) => (
    <div key={item.id} className="bg-border/30 relative rounded-md">
      {/* Item content */}
    </div>
  ))}
</div>
```

### Larger Grid (5 columns)
```tsx
<div className="mt-2 grid grid-cols-2 gap-4 md:grid-cols-5">
  {/* Items */}
</div>
```

### List with Cards
```tsx
<div className="flex flex-col gap-2">
  {items.map((item) => (
    <div key={item.id} className="bg-muted/50 flex w-full flex-row justify-between gap-2 rounded-md p-3">
      {/* Card content */}
    </div>
  ))}
</div>
```

## Icon Pattern

### Icon Container
```tsx
<div className="bg-muted-foreground/20 grid aspect-square h-full place-items-center rounded-md">
  <BoxIcon />
</div>
```

### Icon with Button
```tsx
<Button variant="ghost" size="icon">
  <TrashIcon />
</Button>

<Button variant="outline">
  <InboxArrowDownIcon />
  <span>Label</span>
</Button>
```

## Image Pattern

### Upload Trigger
```tsx
<div className="bg-border/30 relative rounded-md">
  <Button
    variant="ghost"
    size="xs"
    className="absolute top-2 right-2"
  >
    <TrashIcon />
  </Button>
  <Image
    src={imageUrl}
    alt={alt}
    width={200}
    height={200}
    className="aspect-square w-full rounded-md object-cover"
    unoptimized
  />
</div>
```

## Data Fetching Pattern

### Combined Local + Server Data
```tsx
const trpc = useTRPC();
const { data: session } = useSession();

// Server data (conditional)
const serverData = useQuery({
  ...trpc.resource.list.queryOptions(),
  enabled: !!session?.user,
});

// Local data (always)
const localData = useQuery({
  queryKey: ["idb-resource"],
  queryFn: getLocalData,
});

const isLoading = serverData.isLoading || localData.isLoading;
const data = [...(serverData.data ?? []), ...(localData.data ?? [])];
```

## Mutation Pattern

### Standard Mutation with Toast
```tsx
const mutation = useMutation({
  ...trpc.resource.action.mutationOptions(),
  onSuccess: () => {
    toast.success(SUCCESS_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: SUCCESS_MESSAGES.ACTION_SUCCESS,
    });
    queryClient.invalidateQueries({
      queryKey: trpc.resource.list.queryKey()
    });
  },
  onError: (error) => {
    toast.error(ERROR_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: error.message,
    });
  },
});
```

## Best Practices

1. **Keep page.tsx minimal** - delegate to feature components
2. **Use "use client"** for interactive components
3. **Co-locate helpers** in feature directories
4. **Follow import order**: React → UI → Local → Utils → Types
5. **Use TypeScript interfaces** for all props
6. **Provide default values** for optional props
7. **Handle loading and error states** consistently
8. **Use semantic HTML** and proper accessibility attributes
9. **Extract repeated patterns** into reusable components
10. **Keep components focused** - single responsibility
