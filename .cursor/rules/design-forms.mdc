---
description: Form patterns, validation, field components, and form submission conventions
---

# Form Design Patterns

## Form Setup

### Standard Form Pattern
```tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form } from "@/components/ui/form/form";

// Define schema
const formSchema = z.object({
  field: z.string().min(1),
});

type FormSchema = z.infer<typeof formSchema>;

// Component
const Component = () => {
  const form = useForm<FormSchema>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      field: "",
    },
  });

  const onSubmit = (data: FormSchema) => {
    // Handle submission
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
};
```

## Form Field Components

### FormInput Pattern
```tsx
<FormInput
  name="fieldName"
  label="Field Label"
  reactform={form}
  placeholder="Placeholder text"
  description="Helper text for the field"
  isOptional={true} // Shows "(Optional)" in label
  type="text" // or "number", "email", etc.
/>
```

### FormTextarea Pattern
```tsx
<FormTextarea
  className="h-20"
  name="fieldName"
  label="Field Label"
  reactform={form}
  placeholder="Multi-line placeholder"
  description="Helper text"
  isOptional={true}
/>
```

### FormSelect Pattern
```tsx
<FormSelect
  name="fieldName"
  label="Select Label"
  reactform={form}
  defaultValue="default"
  description="Helper text"
>
  <SelectItem value="option1">
    <span>Option 1</span>
    <Badge>Extra Info</Badge>
  </SelectItem>
  <SelectItem value="option2">
    <span>Option 2</span>
  </SelectItem>
</FormSelect>
```

### FormDatePicker Pattern
```tsx
<FormDatePicker
  name="fieldName"
  label="Date Label"
  reactform={form}
  description="Helper text"
/>
```

### FormColorPicker Pattern
```tsx
<FormColorPicker
  name="fieldName"
  label="Color Label"
  reactform={form}
  description="Helper text"
/>
```

## Form Layout Patterns

### FormRow Pattern (Side by Side Fields)
```tsx
import FormRow from "@/components/ui/form/form-row";

<FormRow>
  <FormInput name="field1" label="Field 1" reactform={form} />
  <FormInput name="field2" label="Field 2" reactform={form} />
</FormRow>
```

### Responsive Form Row
```tsx
// Stacks on mobile, row on desktop
<div className="flex flex-col items-center gap-2 sm:flex-row">
  <FormInput name="field1" label="Field 1" reactform={form} />
  <FormInput name="field2" label="Field 2" reactform={form} />
</div>
```

### Form Sections with Accordion
```tsx
<Accordion type="single" collapsible defaultValue="section-id" className="w-full divide-y border-b">
  <AccordionItem value="section-id">
    <AccordionTrigger>Section Title</AccordionTrigger>
    <AccordionContent>
      <FormInput name="field1" label="Field 1" reactform={form} />
      <FormTextarea name="field2" label="Field 2" reactform={form} />
      <FormRow>
        <FormInput name="field3" label="Field 3" reactform={form} />
        <FormInput name="field4" label="Field 4" reactform={form} />
      </FormRow>
    </AccordionContent>
  </AccordionItem>
</Accordion>
```

## Dynamic Field Arrays

### Basic Field Array
```tsx
const { fields, append, remove } = useFieldArray({
  control: form.control,
  name: "items",
});

const addNewField = () => {
  append({
    label: "",
    value: "",
  });
};

return (
  <div className="flex flex-col gap-2">
    <Label>Items</Label>
    {fields.map((field, index) => (
      <div key={field.id} className="flex flex-row items-end gap-2">
        <FormInput
          name={`items.${index}.label`}
          label="Label"
          reactform={form}
          placeholder="Label"
        />
        <FormInput
          name={`items.${index}.value`}
          label="Value"
          reactform={form}
          placeholder="Value"
        />
        <Button
          variant="destructive"
          size="icon"
          onClick={() => remove(index)}
          type="button"
        >
          <TrashIcon />
        </Button>
      </div>
    ))}
    <Button
      className="w-full border-dashed"
      variant="outline"
      onClick={addNewField}
      type="button"
    >
      Add New Field
    </Button>
  </div>
);
```

### Complex Field Array (with nested fields)
```tsx
<div className="flex flex-col items-center gap-2 sm:flex-row" key={field.id}>
  <div className="flex w-full flex-row gap-2 sm:w-2/3">
    <FormInput
      name={`items.${index}.name`}
      reactform={form}
      label="Name"
      placeholder="Name"
    />
    <FormSelect
      name={`items.${index}.type`}
      reactform={form}
      label="Type"
      placeholder="Type"
    >
      <SelectItem value="option1">Option 1</SelectItem>
      <SelectItem value="option2">Option 2</SelectItem>
    </FormSelect>
  </div>
  <div className="flex w-full flex-row items-end gap-2 sm:w-1/3">
    <FormInput
      type="number"
      name={`items.${index}.value`}
      reactform={form}
      label="Value"
      placeholder="Value"
    />
    <Button
      variant="destructive"
      size="icon"
      onClick={() => remove(index)}
      type="button"
    >
      <TrashIcon />
    </Button>
  </div>
</div>
```

## Form Watching and Updates

### Watch Form Values
```tsx
// Watch single field
const fieldValue = form.watch("fieldName");

// Watch multiple fields
const [field1, field2] = form.watch(["field1", "field2"]);

// Watch all values
const formValues = form.getValues();
```

### Conditional Fields Based on Watch
```tsx
{form.watch("theme.template") !== "vercel" && (
  <>
    <FormSelect name="theme.mode" label="Mode" reactform={form}>
      <SelectItem value="dark">Dark</SelectItem>
      <SelectItem value="light">Light</SelectItem>
    </FormSelect>
    <FormColorPicker name="theme.color" label="Color" reactform={form} />
  </>
)}
```

### Set Values Programmatically
```tsx
// Set single value
form.setValue("fieldName", "value");

// Set with validation
form.setValue("fieldName", "value", { shouldValidate: true });

// Reset entire form
form.reset(newDefaultValues);
```

## Form Submission Patterns

### Standard Submit with Mutation
```tsx
const mutation = useMutation({
  ...trpc.resource.create.mutationOptions(),
  onSuccess: () => {
    toast.success(SUCCESS_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: SUCCESS_MESSAGES.RESOURCE_CREATED,
    });
    form.reset();
    queryClient.invalidateQueries({
      queryKey: trpc.resource.list.queryKey()
    });
  },
  onError: (error) => {
    toast.error(ERROR_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: error.message,
    });
  },
});

const onSubmit = (data: FormSchema) => {
  mutation.mutate(data);
};

<form onSubmit={form.handleSubmit(onSubmit)}>
  {/* Fields */}
  <Button type="submit" disabled={mutation.isPending}>
    {mutation.isPending ? "Saving..." : "Save"}
  </Button>
</form>
```

### Submit with Dialog
```tsx
const onHandleSubmit = (data: FormSchema) => {
  // Handle submission
  mutation.mutate(data);

  // Close dialog and reset form
  setOpen(false);
  form.reset();
};

<Form {...form}>
  <form onSubmit={form.handleSubmit(onHandleSubmit)}>
    <DialogContentContainer>
      {/* Form fields */}
    </DialogContentContainer>
    <DialogFooter>
      <DialogClose asChild>
        <Button variant="outline">Cancel</Button>
      </DialogClose>
      <Button type="submit">Submit</Button>
    </DialogFooter>
  </form>
</Form>
```

## Form Validation

### Field-Level Validation (Zod)
```tsx
const schema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  age: z.number().min(18, "Must be 18 or older"),
  url: z.string().url("Must be a valid URL").optional(),
});
```

### Custom Validation
```tsx
const schema = z.object({
  password: z.string(),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});
```

### Conditional Validation
```tsx
const schema = z.object({
  type: z.enum(["email", "phone"]),
  contact: z.string(),
}).refine((data) => {
  if (data.type === "email") {
    return z.string().email().safeParse(data.contact).success;
  }
  return true;
}, {
  message: "Invalid email address",
  path: ["contact"],
});
```

## Special Form Components

### Image Input Component
```tsx
<ImageInput
  isLoading={mutation.isPending}
  allowPreview={false}
  onBase64Change={handleBase64Change}
  maxSizeMB={0.4}
  disableIcon={false}
/>
```

### Signature Input Modal
```tsx
<SignatureInputModal
  isLoading={mutation.isPending}
  onBase64Change={handleBase64Change}
  maxSizeMB={0.15}
  disableIcon={false}
/>
```

### Sheet Image Selector Trigger
```tsx
<SheetImageSelectorTrigger
  type="logo"
  previewUrl={form.watch("companyDetails.logo") ?? undefined}
  onRemove={() => {
    form.setValue("companyDetails.logo", "");
    form.setValue("companyDetails.logoBase64", undefined);
  }}
  label="Company Logo"
/>
```

## Form Dialog Pattern

### Full Dialog Form
```tsx
const [open, setOpen] = useState(false);

const form = useForm<FormSchema>({
  resolver: zodResolver(schema),
  defaultValues: defaultValues,
});

const onSubmit = (data: FormSchema) => {
  // Handle submission
  setOpen(false);
  form.reset();
};

<Dialog open={open} onOpenChange={setOpen}>
  <DialogTrigger asChild>
    <Button>Open Form</Button>
  </DialogTrigger>
  <DialogContent>
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <DialogHeaderContainer>
          <DialogIcon><IconComponent /></DialogIcon>
          <DialogHeader>
            <DialogTitle>Form Title</DialogTitle>
            <DialogDescription>Form description</DialogDescription>
          </DialogHeader>
        </DialogHeaderContainer>
        <DialogContentContainer>
          {/* Form fields */}
        </DialogContentContainer>
        <DialogFooter>
          <DialogClose asChild>
            <Button variant="outline">Cancel</Button>
          </DialogClose>
          <Button type="submit">Submit</Button>
        </DialogFooter>
      </form>
    </Form>
  </DialogContent>
</Dialog>
```

## Form State Management

### Loading States
```tsx
<FormInput
  name="fieldName"
  label="Field"
  reactform={form}
  disabled={mutation.isPending}
/>

<Button type="submit" disabled={mutation.isPending}>
  {mutation.isPending ? "Saving..." : "Save"}
</Button>
```

### Error Display
```tsx
// Errors are automatically shown by form components
// Custom error display:
{form.formState.errors.fieldName && (
  <p className="text-destructive text-xs">
    {form.formState.errors.fieldName.message}
  </p>
)}
```

### Dirty/Touched State
```tsx
// Check if form has been modified
const isDirty = form.formState.isDirty;

// Check specific field
const isFieldDirty = form.formState.dirtyFields.fieldName;

// Warn before leaving
useEffect(() => {
  const handleBeforeUnload = (e: BeforeUnloadEvent) => {
    if (form.formState.isDirty) {
      e.preventDefault();
      e.returnValue = '';
    }
  };
  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [form.formState.isDirty]);
```

## Form Descriptions and Labels

### Field with Description
```tsx
<FormInput
  name="fieldName"
  label="Field Label"
  reactform={form}
  description="Helper text explaining the field"
  placeholder="Enter value"
/>
```

### Optional Field
```tsx
<FormInput
  name="fieldName"
  label="Field Label"
  reactform={form}
  isOptional={true} // Adds "(Optional)" to label
/>
```

### Field with Sublabel
```tsx
<FormInput
  name="fieldName"
  label="Label"
  sublabel="Tax/Discount/Other"
  reactform={form}
  isOptional={true}
/>
```

## Best Practices

1. **Always use Zod schemas** for form validation
2. **Use zodResolver** with react-hook-form
3. **Provide default values** for all fields
4. **Use FormRow** for horizontal field layouts
5. **Show loading states** during submission
6. **Display toast notifications** on success/error
7. **Invalidate queries** after successful mutations
8. **Reset form** after successful submission
9. **Use type="button"** for non-submit buttons in forms
10. **Mark optional fields** with isOptional prop
11. **Provide descriptions** for complex fields
12. **Use field arrays** for dynamic lists
13. **Wrap forms in <Form>** component for proper context
14. **Handle validation errors** gracefully
15. **Test form accessibility** (keyboard navigation, screen readers)
