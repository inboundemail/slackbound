---
description: State management, data fetching, mutations, and UI interaction patterns
---

# Data and State Management Patterns

## State Management Strategy

### Local Component State
Use `useState` for simple, component-scoped state:
```tsx
const [open, setOpen] = useState(false);
const [loading, setLoading] = useState(true);
const [selectedItem, setSelectedItem] = useState<Item | null>(null);
```

### Global State (Jotai)
Use Jotai atoms for cross-component state:
```tsx
// Define atom
import { atom } from "jotai";

export const invoiceTabAtom = atom<"form" | "preview" | "both">("both");
export const invoiceErrorAtom = atom<ZodIssue[]>([]);

// Use in component
import { useAtom, useAtomValue, useSetAtom } from "jotai";

// Read and write
const [tab, setTab] = useAtom(invoiceTabAtom);

// Read only
const errors = useAtomValue(invoiceErrorAtom);

// Write only
const setErrors = useSetAtom(invoiceErrorAtom);
```

### Form State (React Hook Form)
Use react-hook-form for form state:
```tsx
const form = useForm<FormSchema>({
  resolver: zodResolver(schema),
  defaultValues: defaultValues,
});

// Access values
const value = form.watch("fieldName");
const allValues = form.getValues();

// Set values
form.setValue("fieldName", value);
form.reset(newValues);
```

## Data Fetching Patterns

### tRPC Query Pattern
```tsx
const trpc = useTRPC();
const { data: session } = useSession();

const query = useQuery({
  ...trpc.resource.list.queryOptions(),
  enabled: !!session?.user, // Conditional fetching
});

// Access query state
if (query.isLoading) return <LoadingState />;
if (query.isError) return <ErrorState error={query.error} />;
if (!query.data) return <EmptyState />;

// Use data
const items = query.data;
```

### IndexedDB Query Pattern
```tsx
const localQuery = useQuery({
  queryKey: ["idb-resource"],
  queryFn: () => getAllResourcesFromIDB(),
});

// Always runs (not conditional on auth)
```

### Combined Local + Server Data
```tsx
const trpc = useTRPC();
const { data: session } = useSession();

// Server data (authenticated users only)
const serverData = useQuery({
  ...trpc.resource.list.queryOptions(),
  enabled: !!session?.user,
});

// Local data (all users)
const localData = useQuery({
  queryKey: ["idb-resource"],
  queryFn: getAllLocalResources,
});

// Loading state (wait for both)
const isLoading = serverData.isLoading || localData.isLoading;

// Combine data
const data = [...(serverData.data ?? []), ...(localData.data ?? [])];
```

### Dependent Queries
```tsx
// Query 1
const userQuery = useQuery({
  queryKey: ["user"],
  queryFn: getUser,
});

// Query 2 depends on Query 1
const projectsQuery = useQuery({
  queryKey: ["projects", userQuery.data?.id],
  queryFn: () => getProjects(userQuery.data!.id),
  enabled: !!userQuery.data, // Only run when user data exists
});
```

## Mutation Patterns

### Standard Mutation with Optimistic Updates
```tsx
const queryClient = useQueryClient();

const mutation = useMutation({
  ...trpc.resource.create.mutationOptions(),
  onMutate: async (newResource) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({
      queryKey: trpc.resource.list.queryKey()
    });

    // Snapshot previous value
    const previousResources = queryClient.getQueryData(
      trpc.resource.list.queryKey()
    );

    // Optimistically update
    queryClient.setQueryData(
      trpc.resource.list.queryKey(),
      (old) => [...(old ?? []), newResource]
    );

    return { previousResources };
  },
  onError: (err, newResource, context) => {
    // Rollback on error
    queryClient.setQueryData(
      trpc.resource.list.queryKey(),
      context?.previousResources
    );

    toast.error(ERROR_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: err.message,
    });
  },
  onSuccess: () => {
    toast.success(SUCCESS_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: SUCCESS_MESSAGES.RESOURCE_CREATED,
    });
  },
  onSettled: () => {
    // Always refetch after mutation
    queryClient.invalidateQueries({
      queryKey: trpc.resource.list.queryKey()
    });
  },
});
```

### Simple Mutation with Toast
```tsx
const mutation = useMutation({
  ...trpc.resource.delete.mutationOptions(),
  onSuccess: () => {
    toast.success(SUCCESS_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: SUCCESS_MESSAGES.RESOURCE_DELETED,
    });

    queryClient.invalidateQueries({
      queryKey: trpc.resource.list.queryKey()
    });
  },
  onError: (error) => {
    toast.error(ERROR_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: error.message,
    });
  },
});

// Usage
<Button
  onClick={() => mutation.mutate({ id: item.id })}
  disabled={mutation.isPending}
>
  {mutation.isPending ? "Deleting..." : "Delete"}
</Button>
```

### Multiple Mutations Pattern
```tsx
// Server mutation
const serverMutation = useMutation({
  ...trpc.resource.action.mutationOptions(),
  onSuccess: () => {
    queryClient.invalidateQueries({
      queryKey: trpc.resource.list.queryKey()
    });
  },
});

// Local mutation (IndexedDB)
const localMutation = useMutation({
  mutationFn: (data) => saveToIndexedDB(data),
  onSuccess: () => {
    queryClient.invalidateQueries({
      queryKey: ["idb-resource"]
    });
  },
});

// Handler that chooses which mutation
const handleSave = async (data: FormData) => {
  if (session?.user?.allowedSavingData) {
    serverMutation.mutate(data);
  } else {
    localMutation.mutate(data);
  }
};
```

## Query Invalidation Patterns

### Invalidate Single Query
```tsx
queryClient.invalidateQueries({
  queryKey: trpc.resource.list.queryKey()
});
```

### Invalidate Multiple Queries
```tsx
queryClient.invalidateQueries({
  queryKey: [
    "idb-resource",
    ...(user ? [trpc.resource.list.queryKey()] : [])
  ]
});
```

### Invalidate with Predicate
```tsx
queryClient.invalidateQueries({
  predicate: (query) =>
    query.queryKey[0] === "resource" ||
    query.queryKey[0] === "idb-resource"
});
```

## Loading States

### Component Loading State
```tsx
if (query.isLoading) {
  return (
    <div className="flex h-full items-center justify-center">
      <EmptySection
        title="Loading..."
        description="Please wait while we load your data"
      />
    </div>
  );
}
```

### Inline Loading State
```tsx
<Button disabled={mutation.isPending}>
  {mutation.isPending ? "Saving..." : "Save"}
</Button>

<div className={cn(
  isLoading && "opacity-50 pointer-events-none"
)}>
  {/* Content */}
</div>
```

### Skeleton Loading
```tsx
{isLoading ? (
  <div className="space-y-2">
    <Skeleton className="h-10 w-full" />
    <Skeleton className="h-10 w-full" />
    <Skeleton className="h-10 w-full" />
  </div>
) : (
  <ActualContent />
)}
```

## Error Handling

### Query Error State
```tsx
if (query.isError) {
  return (
    <div className="flex h-full items-center justify-center text-red-500">
      <EmptySection
        title={ERROR_MESSAGES.DEFAULT}
        description={query.failureReason?.message || "An error occurred"}
      />
    </div>
  );
}
```

### Error with Retry
```tsx
if (query.isError) {
  return (
    <Alert variant="destructive">
      <AlertTitle>Error Loading Data</AlertTitle>
      <AlertDescription>
        {query.error.message}
      </AlertDescription>
      <AlertButtonGroup>
        <Button
          onClick={() => query.refetch()}
          variant="destructive"
          size="xs"
        >
          Retry
        </Button>
      </AlertButtonGroup>
    </Alert>
  );
}
```

### Try-Catch with neverthrow
```tsx
import { asyncTryCatch } from "@/lib/neverthrow/tryCatch";

const handleAction = async () => {
  const { success, error } = await asyncTryCatch(
    performAsyncOperation()
  );

  if (!success) {
    toast.error(ERROR_MESSAGES.TOAST_DEFAULT_TITLE, {
      description: error.message,
    });
    return;
  }

  toast.success(SUCCESS_MESSAGES.TOAST_DEFAULT_TITLE, {
    description: "Operation completed successfully",
  });
};
```

## Toast Notification Patterns

### Success Toast
```tsx
toast.success(SUCCESS_MESSAGES.TOAST_DEFAULT_TITLE, {
  description: SUCCESS_MESSAGES.ACTION_SUCCESS,
});
```

### Error Toast
```tsx
toast.error(ERROR_MESSAGES.TOAST_DEFAULT_TITLE, {
  description: error.message,
});
```

### Promise Toast
```tsx
toast.promise(
  asyncOperation(),
  {
    loading: "Processing...",
    success: "Operation completed!",
    error: "Operation failed",
  }
);
```

## User Session Pattern

### Check Authentication
```tsx
import { useSession } from "@/lib/client-auth";

const { data: session } = useSession();

// Conditional rendering based on auth
{session?.user && (
  <AuthenticatedFeature />
)}

// Conditional data fetching
const query = useQuery({
  ...trpc.resource.list.queryOptions(),
  enabled: !!session?.user,
});
```

### Check User Permissions
```tsx
{session?.user?.allowedSavingData && (
  <UploadToServerFeature />
)}

{!session?.user?.allowedSavingData && (
  <LocalOnlyMessage />
)}
```

## Debouncing and Throttling

### Debounced Form Updates
```tsx
import { debounce } from "lodash";

useEffect(() => {
  const processValue = (value: FormData) => {
    // Process the value
    validateAndUpdate(value);
  };

  const debouncedProcess = debounce(processValue, 1000);

  const subscription = form.watch((value) => {
    debouncedProcess(value);
  });

  return () => {
    subscription.unsubscribe();
    debouncedProcess.cancel();
  };
}, [form]);
```

### Throttled Search
```tsx
import { throttle } from "lodash";

const [searchTerm, setSearchTerm] = useState("");

const throttledSearch = useMemo(
  () => throttle((term: string) => {
    performSearch(term);
  }, 500),
  []
);

const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const term = e.target.value;
  setSearchTerm(term);
  throttledSearch(term);
};
```

## Conditional UI Rendering

### Based on Data State
```tsx
{data.length === 0 ? (
  <EmptyState />
) : (
  <DataList data={data} />
)}
```

### Based on User Type
```tsx
{session?.user ? (
  <>
    {/* Show both server and local */}
    <ServerSection />
    <LocalSection />
  </>
) : (
  <>
    {/* Show only local */}
    <LocalSection />
  </>
)}
```

### Based on Feature Flag
```tsx
{user?.features?.newFeature && (
  <BetaFeature />
)}
```

## Polling Pattern

### Auto-refresh Query
```tsx
const query = useQuery({
  ...trpc.resource.list.queryOptions(),
  refetchInterval: 30000, // Refresh every 30 seconds
  refetchIntervalInBackground: false, // Don't poll when tab is inactive
});
```

### Manual Refresh
```tsx
const query = useQuery({
  ...trpc.resource.list.queryOptions(),
});

<Button onClick={() => query.refetch()}>
  Refresh
</Button>
```

## Optimistic UI Updates

### Immediate Feedback Pattern
```tsx
const [optimisticData, setOptimisticData] = useState(data);

const mutation = useMutation({
  ...trpc.resource.update.mutationOptions(),
  onMutate: async (updatedItem) => {
    // Immediately update UI
    setOptimisticData(prev =>
      prev.map(item =>
        item.id === updatedItem.id ? updatedItem : item
      )
    );
  },
  onError: () => {
    // Revert on error
    setOptimisticData(data);
  },
  onSuccess: () => {
    // Sync with server
    queryClient.invalidateQueries({
      queryKey: trpc.resource.list.queryKey()
    });
  },
});

// Render optimistic data
<DataList data={optimisticData} />
```

## Analytics Pattern

### Track User Actions
```tsx
import { useAnalytics } from "@/hooks/use-analytics";

const analytics = useAnalytics();

const handleAction = () => {
  // Perform action
  performAction();

  // Track event
  analytics.capture("action-performed", {
    elementGroup: "feature-name" satisfies AnalyticsEventGroup,
    metadata: { additional: "data" },
  });
};
```

## Best Practices

1. **Use React Query** for all async data fetching
2. **Combine server + local data** for hybrid storage
3. **Always handle loading states** - show skeleton or spinner
4. **Always handle error states** - provide retry option
5. **Use optimistic updates** for better UX
6. **Invalidate queries** after mutations
7. **Show toast notifications** for user feedback
8. **Debounce expensive operations** like API calls
9. **Enable queries conditionally** based on dependencies
10. **Use Jotai** for cross-component state
11. **Keep component state local** when possible
12. **Track important user actions** with analytics
13. **Handle auth conditionally** - check session before server calls
14. **Provide empty states** when no data
15. **Test error boundaries** for unexpected failures
